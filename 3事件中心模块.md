降低程序耦合性，减少程序复杂度
Dictionary，委托，观察者设计模式（事件中心模块就是基于此设计的），<font color="red">接口的“分类”用法。</font>
Dictionary 存储的是事件的名字与对应的多个委托函数

```csharp
public interface IEventInfo  
{  
  
}  
  
public class EventInfo<T> : IEventInfo  
{  
    public UnityAction<T> actions;  
  
    public EventInfo( UnityAction<T> action)  
    {        
	    actions += action;  
    }
}  
  
public class EventInfo : IEventInfo  
{  
    public UnityAction actions;  
  
    public EventInfo(UnityAction action)  
    {        
	    actions += action;  
    }
}
```
事件中心：核心是 EventListener 与 EventTrigger，还有要注意解除事件监听，因为场景中对象销毁后要是还是有监听关系可能有内存泄漏的风险。这里的 Dictionary 用我们上面写得 IEventInfo 是为了避免使用 object 进行拆箱装箱。
==不直接使用 "UnityAction<>"是因为类里面用泛型成员变量的时候类本身要是一个泛型类。
所以我们这里用里氏替换原则，用父类装子类包裹一层。这样字典里就不用写泛型了。==

```csharp
// 事件中心 单例模式对象  
// 1.Dictionary  
// 2.委托  
// 3.观察者设计模式  
// 4.泛型  

public class EventCenter : BaseManager<EventCenter>  
{  
    //key —— 事件的名字（比如：怪物死亡，玩家死亡，通关 等等）  
    //value —— 对应的是 监听这个事件 对应的委托函数们  
    private Dictionary<string, IEventInfo> eventDic = new Dictionary<string, IEventInfo>();  
  
    /// <summary>  
    /// 添加事件监听  
    /// </summary>  
    /// <param name="name">事件的名字</param>  
    /// <param name="action">准备用来处理事件 的委托函数</param>  
    public void AddEventListener<T>(string name, UnityAction<T> action)  
    {        
	    //有没有对应的事件监听  
        //有的情况  
        if( eventDic.ContainsKey(name) )  
        {            
	        (eventDic[name] as EventInfo<T>).actions += action;  
        }        
        //没有的情况  
        else  
        {  
            eventDic.Add(name, new EventInfo<T>( action ));  
        }    
    }  
    
    // 监听不需要参数传递的事件  
    public void AddEventListener(string name, UnityAction action)  
    {        
	    //有没有对应的事件监听  
        //有的情况  
        if (eventDic.ContainsKey(name))  
        {            
	        (eventDic[name] as EventInfo).actions += action;  
        }        
        //没有的情况  
        else  
        {  
            eventDic.Add(name, new EventInfo(action));  
        }    
    }  
  
    /// <summary>  
    /// 移除对应的事件监听  
    /// </summary>  
    /// <param name="name">事件的名字</param>  
    /// <param name="action">对应之前添加的委托函数</param>  
    public void RemoveEventListener<T>(string name, UnityAction<T> action)  
    {        if (eventDic.ContainsKey(name))  
            (eventDic[name] as EventInfo<T>).actions -= action;  
    }  
      
    // 移除不需要参数的事件  
    public void RemoveEventListener(string name, UnityAction action)  
    {        if (eventDic.ContainsKey(name))  
            (eventDic[name] as EventInfo).actions -= action;  
    }  
    
    /// <summary>  
    /// 事件触发  
    /// </summary>  
    /// <param name="name">哪一个名字的事件触发了</param>  
    public void EventTrigger<T>(string name, T info)  
    {        
	    //有没有对应的事件监听  
        //有的情况  
        if (eventDic.ContainsKey(name))  
        {            
	        //eventDic[name]();  
            if((eventDic[name] as EventInfo<T>).actions != null)  
                (eventDic[name] as EventInfo<T>).actions.Invoke(info);  
            //eventDic[name].Invoke(info);  
        }  
        //没有的话什么都不用做
    }  
     
    // 事件触发（不需要参数的）  
    public void EventTrigger(string name)  
    {        
	    //有没有对应的事件监听  
        //有的情况  
        if (eventDic.ContainsKey(name))  
        {           
	         //eventDic[name]();  
            if ((eventDic[name] as EventInfo).actions != null)  
                (eventDic[name] as EventInfo).actions.Invoke();  
            //eventDic[name].Invoke(info);  
        }  
    }  
     
    // 清空事件中心  
    // 主要用在 场景切换时  
    public void Clear()  
    {        
	    eventDic.Clear();  
    }
}
```
使用：
```csharp
public class Player:Monobehaviour{
	void Start(){
		EventCenter.GetInstance().AddEventListener<Monster>("MonsterDead",MonsterDeadDo);
	}
	
	public void MonsterDeadDo(){}

	void OnDestroy(){
		EventCenter.GetInstence(),RemoveEventListener<Monster>("MonsterDead",MonsterDeadDo);
	}
}
```
```csharp
public class Monster:Monobehavoiur{
	void Dead(){
	EventCenter.GetInstance().EventTrigger<Monster>("MonsterDead");
	}
}
```
