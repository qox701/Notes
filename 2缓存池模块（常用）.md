节约性能，减少 cpu 和内存消耗。
使用 Dictionary, List, GameObject。
注意我们的缓存池可能存储的是不同的对象，比如子弹一个对象、火光一个对象、弹痕一个对象。
所以我们缓存池作为一个大衣柜（Dictionary）里面要有不同的抽屉（List）。
"抽屉"模块：包含一个父节点和一个 List
```csharp
public class PoolData  
{  
    //抽屉中 对象挂载的父节点  
    public GameObject fatherObj;  
    //对象的容器  
    public List<GameObject> poolList;  
  
    public PoolData(GameObject obj, GameObject poolObj)  
    {        
	    //给我们的抽屉 创建一个父对象 并且把他作为我们pool(衣柜)对象的子物体  
        fatherObj = new GameObject(obj.name);  
        fatherObj.transform.parent = poolObj.transform;  
        poolList = new List<GameObject>() {};  
        PushObj(obj);  
    }  
    
	// 往抽屉里面 压都东西  
    public void PushObj(GameObject obj)  
    {        //失活 让其隐藏  
        obj.SetActive(false);  
        //存起来  
        poolList.Add(obj);  
        //设置父对象  
        obj.transform.parent = fatherObj.transform;  
    }  
    
    /// 从抽屉里面 取东西     
    public GameObject GetObj()  
    {        
	    GameObject obj = null;  
        //取出第一个  
        obj = poolList[0];  
        poolList.RemoveAt(0);  
        //激活 让其显示  
        obj.SetActive(true);  
        //断开了父子关系  
        obj.transform.parent = null;  
  
        return obj;  
    }}
```
缓存池模块：
```csharp
public class PoolMgr : BaseManager<PoolMgr>  
{  
    //缓存池容器 （衣柜）  
    public Dictionary<string, PoolData> poolDic = new Dictionary<string, PoolData>();  
  
    private GameObject poolObj;  
  
    // 往外拿东西  
    public void GetObj(string name, UnityAction<GameObject> callBack)  
    {        
    //有抽屉 并且抽屉里有东西  
        if (poolDic.ContainsKey(name) && poolDic[name].poolList.Count > 0)  
        {            
	        callBack(poolDic[name].GetObj());  
        }        
        else  
        {  
            //通过异步加载资源 创建对象给外部用  
            ResMgr.GetInstance().LoadAsync<GameObject>(name, (o) =>  
            {  
                o.name = name;  
                callBack(o);            
            });  
            //obj = GameObject.Instantiate(Resources.Load<GameObject>(name));  
            //把对象名字改的和池子名字一样  
            //obj.name = name;  
        }  
    }  
      
    /// 换暂时不用的东西给我  
    public void PushObj(string name, GameObject obj)  
    {        
	    if (poolObj == null)  
            poolObj = new GameObject("Pool");  
  
        //里面有抽屉  
        if (poolDic.ContainsKey(name))  
        {            
	        poolDic[name].PushObj(obj);  
        }        
        //里面没有抽屉  
        else  
        {  
            poolDic.Add(name, new PoolData(obj, poolObj));  
        }    
    }  
  
     
    // 清空缓存池的方法   
	// 主要用在 场景切换时  
    public void Clear()  
    {        
	    poolDic.Clear();  
        poolObj = null;  
    }
}
```
使用：
典型的使用单例模式的方式
```csharp
PoolMgr.GetInstance().GetObj("Test/Cube");//Cube是一个预设体
```
若想物体自动销毁，然后存进缓存池，则需要写脚本挂载到那个预设体上面。